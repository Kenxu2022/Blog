

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  
    <link rel="canonical" href="https://blog.kenxu.top/post/bypass-gfw-p2/"/>
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ken">
  <meta name="keywords" content="">
  
    <meta name="description" content="越过长城，走向世界">
<meta property="og:type" content="article">
<meta property="og:title" content="聊聊那些翻山越岭的神奇操作（中）">
<meta property="og:url" content="https://blog.kenxu.top/post/bypass-gfw-p2/index.html">
<meta property="og:site_name" content="Ken&#39;s Blog">
<meta property="og:description" content="越过长城，走向世界">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.kenxu.top/img/%E8%81%8A%E8%81%8A%E9%82%A3%E4%BA%9B%E7%BF%BB%E5%B1%B1%E8%B6%8A%E5%B2%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%AD%EF%BC%89.png">
<meta property="article:published_time" content="2025-08-16T18:30:00.000Z">
<meta property="article:modified_time" content="2025-08-16T18:37:34.863Z">
<meta property="article:author" content="Ken">
<meta property="article:tag" content="network">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.kenxu.top/img/%E8%81%8A%E8%81%8A%E9%82%A3%E4%BA%9B%E7%BF%BB%E5%B1%B1%E8%B6%8A%E5%B2%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%AD%EF%BC%89.png">
<meta name="twitter:creator" content="@kenxu2022">
  
  
  
  <title>聊聊那些翻山越岭的神奇操作（中） - Ken&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.kenxu.top","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":5},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"BnqG01I5hAArZnRatgyoTyJa-gzGzoHsz","app_key":"ViWN7reESSbk8Yh8jQWSrvPm","server_url":"https://bnqg01i5.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Ken's Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ken&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml" target="_self">
                <i class="iconfont icon-rss"></i>
                <span>RSS</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/ba.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">聊聊那些翻山越岭的神奇操作（中）</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-17 02:30" pubdate>
          2025年8月17日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">聊聊那些翻山越岭的神奇操作（中）</h1>
            
            
              <div class="markdown-body">
                
                <p>书接<a href="https://blog.kenxu.top/post/bypass-gfw-p1/">上回</a>，上回说到可以通过域前置的手段绕开防火墙的阻断，但缺点也很显而易见：支持的网站和设备都有限（而且似乎不是很优雅），那有没有什么别的翻山越岭的方法呢？</p>
<h1 id="劫持与污染"><a href="#劫持与污染" class="headerlink" title="劫持与污染"></a>劫持与污染</h1><p>众所周知，传统的DNS查询使用的是UDP协议，DNS服务器一般监听在53端口。这里有两个问题：一是查询的流量是明文的，任何中间人都可以监听并篡改DNS服务器返回的结果，二是DNS查询固定会使用53端口，流量特征明显，非常容易被识别并加以干扰。<br>DNS查询采用的是“递归解析”的方法，假如需要查询<code>blog.kenxu.top</code>的IP，需要先查询<code>.top</code>这个TLD对应的解析服务器，再由<code>.top</code>顶级域服务器查询<code>kenxu.top</code>的解析服务器，最终由这个一级域服务器查询<code>blog.kenxu.top</code>这个二级域名的IP。<br><img src="/post/bypass-gfw-p2/1.png" srcset="/img/loading.gif" lazyload alt="由于博客域名采用CNAME方式接入，所以这里会查询到Netlify随机生成的域名"><br>那么，防火墙是如何利用DNS的查询过程进行审查和阻断的呢？在递归解析的过程中，防火墙会识别DNS查询的流量并对查询的域名进行检测，一旦匹配到黑名单中的域名，便会伪装成目标DNS服务器返回虚假的解析结果。由于各级DNS服务器都会缓存查询结果，境内的DNS服务器除了会向用户返回错误的DNS解析结果，还会将这个错误的结果缓存下来，将来有其他用户查询时便直接返回这个错误的结果。<br>综上所述，在查询黑名单网站时，如果你使用的是境内的DNS服务器，你收到的是来自缓存污染后的结果；如果你使用的是境外的DNS服务器，你收到的是防火墙劫持后的结果。验证的方法很简单，随意查询一个黑名单内的地址即可：<br><img src="/post/bypass-gfw-p2/2.png" srcset="/img/loading.gif" lazyload><br>使用Cloudflare提供的公共DNS举例，作为对比，阿里云DNS的查询时间一般在10ms左右（同城），广州-香港IEPL端内的时延一般在6ms左右。如此短的查询耗时说明除非用的是比光更快的传输介质，不然一定是被防火墙劫持了（</p>
<h1 id="DoT与DoH"><a href="#DoT与DoH" class="headerlink" title="DoT与DoH"></a>DoT与DoH</h1><p>如何解决劫持和污染的问题？<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7858">DNS over TLS (DoT)</a> 和 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8484">DNS over HTTPS (DoH)</a> 的相关规范于2016年和2018年制定完成，解决了传统DNS无加密和特征强的问题。<br>DoT的思路比较简单，即直接用TLS加密原先明文的DNS查询流量，通过TCP协议进行连接，并使用853端口作为常用端口。中间人虽然无法解密查询流量，但仍然可以通过连接目标服务器的端口判断用户正在使用DoT查询DNS，进而阻断流量。<br><img src="/post/bypass-gfw-p2/3.png" srcset="/img/loading.gif" lazyload alt="友情出镜：`dot.pub`，通过端口即可判断出正在使用DoT"><br>除此之外还有一些别的特征，例如DoT流量在发送TLS ClientHello数据包时，一般不会包含ALPN (Application Layer Protocol Negotiation) 扩展，但端口号这个特征其实已经足够明显，此处按下不表。<br>而DoH在同样采用TCP连接与TLS加密的基础上，将DNS查询封装成了HTTP请求，并使用443端口，使其在流量特征上与一般浏览网页的HTTP流量无异，中间人除了无法监听和篡改DNS查询的结果，甚至无法得知用户正在进行DNS查询。<br><img src="/post/bypass-gfw-p2/4.png" srcset="/img/loading.gif" lazyload alt="DoH使用443端口，与普通HTTP流量相同"><br>由于进行了HTTP封装，因此DoH的开销会略大于DoT，数据包的体积和数量会略微增大（例如ClientHello中的ALPN，数据包中的HTTP HEADER），但考虑到其相对DoT增强的安全性，以及HTTP&#x2F;2带来的多路复用等特性，这点开销也是可以接受的。</p>
<p>DoT和DoH并非完美无缺的解决方案，其缺点也很明显，其中绕不开的一点就是查询时间。TCP协议+TLS加密的方式，使得DoT和DoH查询DNS相较传统方案增加了两个RTT的时延（如果使用的是TLS1.2，甚至是3个RTT），查询耗时相比基于UDP的方案大大增加。<br><img src="/post/bypass-gfw-p2/5.png" srcset="/img/loading.gif" lazyload alt="UDP DNS, ~13ms"><br><img src="/post/bypass-gfw-p2/6.png" srcset="/img/loading.gif" lazyload alt="DoT, ~49ms"><br><img src="/post/bypass-gfw-p2/7.png" srcset="/img/loading.gif" lazyload alt="DoH, ~51ms"></p>
<p>DoT和DoH是否可以完美突破审查？实则不然。首先，审查者可以记录境外目标DNS服务器的IP地址，在防火墙侧直接丢弃去往这个IP的数据包；同时，无论是DoT还是DoH，都使用了TLS进行加密，在上篇中有提到，TLS存在着SNI——服务器名称指示这一扩展，其中<strong>明文</strong>记载了访问网站的信息，也就是说，审查者完全可以像屏蔽其他网站一样，根据SNI中的信息屏蔽相应的DoH流量。<br>事实上，根据笔者的印象，在DoH还没有推广开来的时候（约2021年以前），仍然可以在境内访问大多数海外的DoH服务器，例如Chrome和Firefox自带的<code>OpenDNS</code>和<code>NextDNS</code>，而随着这两年审查力度的逐渐加大，这些位于境外的DoT和DoH服务器也无一例外地享受到了SNI阻断的待遇。  </p>
<p>使用OpenDNS的DoH实例测试，可以看出，ping所使用的ICMP协议可以正常通过防火墙并收到目标服务器的回应。<br><img src="/post/bypass-gfw-p2/8.png" srcset="/img/loading.gif" lazyload alt="ICMP Ping"><br>而使用DoH查询时，笔者同时观测到了上述的两种封锁方法：对于TCP数据包的<strong>丢弃</strong>和对于TLS流量的SNI<strong>阻断</strong>。<br><img src="/post/bypass-gfw-p2/9.png" srcset="/img/loading.gif" lazyload alt="丢弃TCP数据包"><br><img src="/post/bypass-gfw-p2/10.png" srcset="/img/loading.gif" lazyload alt="SNI阻断，RST重置"><br>目前，除非自行在海外VPS上搭建DNS服务器，否则几乎所有公共DoT和DoH实例都是无法连接的。</p>
<h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><p>传统的TCP,UDP协议和TLS加密似乎都不足以解决眼下的问题。如同数十年前，HTTP&#x2F;2出现之前的HTTP&#x2F;1.1——与其在旧协议上缝缝补补，不如直接创造一个新的协议。早在2012年，Google就开始着手研发一种全新的协议，旨在替代传统浏览互联网所使用的HTTP协议。2015年，有关QUIC的草案交由IETF开始标准化，并逐渐转化为一种通用的传输协议。2021年，QUIC在<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>中正式标准化。<br><img src="/post/bypass-gfw-p2/11.png" srcset="/img/loading.gif" lazyload alt="HTTP-1.1 vs. HTTP-2 vs. HTTP-3 Protocol Stack&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;图片来源：https://en.wikipedia.org/wiki/File:HTTP-1.1_vs._HTTP-2_vs._HTTP-3_Protocol_Stack.svg , [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.en)&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;"><br>QUIC是一种基于UDP的传输层协议。其解决了传统基于TCP的协议面临的一个老大难问题——队头阻塞。HTTP&#x2F;2虽然增加了多路复用的特性，但多个数据包跑在一个同一个TCP连接之上，一旦发生丢包，整个连接就会阻塞，直到重传丢掉的包。在2%的丢包率下，HTTP&#x2F;2的表现甚至不如HTTP&#x2F;1。而基于UDP的QUIC在单个连接中的流是互相独立的，意味着即使发生丢包，也不会阻塞其他流，只要重传丢失的数据帧（例如STREAM frame, ACK frame, CRYPTO frame等等）即可。  </p>
<pre><code class=" mermaid">graph TD
    A[QUIC Connection] --&gt; B[Stream 1]
    A --&gt; C[Stream 2]
    A --&gt; D[Stream 3]

    B --&gt; B1[STREAM Frame 1]
    B --&gt; B2[STREAM Frame 2]
    B --&gt; B3[CRYPTO Frame]

    C --&gt; C1[STREAM Frame 1]
    C --&gt; C2[ACK Frame]

    D --&gt; D1[STREAM Frame 1]
    D --&gt; D2[STREAM Frame 2]
    D --&gt; D3[STREAM Frame 3]

    style A fill:#bbf,stroke:#333,stroke-width:2px
    style B fill:#bfb,stroke:#333,stroke-width:1px
    style C fill:#bfb,stroke:#333,stroke-width:1px
    style D fill:#bfb,stroke:#333,stroke-width:1px
    style B1 fill:#ffd,stroke:#333,stroke-width:1px
    style B2 fill:#ffd,stroke:#333,stroke-width:1px
    style B3 fill:#ffd,stroke:#333,stroke-width:1px
    style C1 fill:#ffd,stroke:#333,stroke-width:1px
    style C2 fill:#ffd,stroke:#333,stroke-width:1px
    style D1 fill:#ffd,stroke:#333,stroke-width:1px
    style D2 fill:#ffd,stroke:#333,stroke-width:1px
    style D3 fill:#ffd,stroke:#333,stroke-width:1px
</code></pre>
<p>此外，与TCP和UDP这类传统的传输层协议不同，QUIC的职能向上延伸到了TLS所在的层级（传输层之上，应用层之下）。QUIC协议强制要求使用TLS 1.3对流量进行加密，不仅进一步提升了安全性，更利用上了TLS 1.3带来的0-RTT特性，利用首次连接记录的预共享密钥直接向服务端发送数据，进一步降低时延。<br>那么，QUIC又是怎样对待在TLS握手阶段明文的Client Hello信息呢？QUIC同样对其进行了加密，但要如何在握手阶段就能够让服务端解密数据呢？其实这里使用的并非TLS加密，事实上无论协议如何变化，任何非对称加密都必须在密钥交换环节后才能进行。QUIC对于握手阶段的加密，其实是对称加密，这点在QUIC相关的<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc9001">RFC文档</a>中有详细定义，这里只截取其中的一小段：</p>
<blockquote>
<p>This secret is determined by using HKDF-Extract with a salt of <code>0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</code> and the input keying material (IKM) of the Destination Connection ID field. This produces an intermediate pseudorandom key (PRK) that is used to derive two separate secrets for sending and receiving.<br>The current encryption level secret and the label “quic key” are input to the KDF to produce the AEAD key; the label “quic iv” is used to derive the Initialization Vector (IV). The header protection key uses the “quic hp” label. Using these labels provides key separation between QUIC and TLS.<br>Both “quic key” and “quic hp” are used to produce keys, so the Length provided to HKDF-Expand-Label along with these labels is determined by the size of keys in the AEAD or header protection algorithm.</p>
</blockquote>
<p>QUIC在建立连接阶段，会使用<code>Initial Packet</code>和<code>Handshake Packet</code>进行握手和密钥交换。对于<code>Initial Packet</code>中的握手信息，会先使用DCID（由客户端生成）<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="`DCID`即 Destination Connection ID，代表连接对方的ID，初次连接时由客户端随机生成，服务端接收连接后会生成 `SCID`(Source Connection ID)代表己方发回给客户端，之后的阶段客户端便会使用这个ID作为 `DCID`，在截图中亦有体现">[2]</span></a></sup>和一个固定密钥（与QUIC版本相关）派生出初始密钥，分别用于客户端和服务端，再根据这个初始密钥派生出对称加密和包头混淆所需要的<code>key</code>,<code>iv</code>和<code>hp</code>。服务端收到<code>Initial Packet</code>后，读取明文的DCID信息，并按同样的流程生成初始密钥<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="服务端需要生成两组初始密钥，一组用于解密客户端发来的包（`client_initial_secret`），另一组用于加密发给客户端的 `Handshake Packet`（`server_initial_secret`）">[3]</span></a></sup>并派生出解密所需要的密钥。<br><img src="/post/bypass-gfw-p2/12.png" srcset="/img/loading.gif" lazyload alt="QUIC协议的握手流程，`Protected Payload`即代表建立连接阶段结束，开始发送数据"></p>
<p>也就是说，加密<code>Initial Packet</code>的信息，都是公开可推导的。这里的加密本身不保证机密性，但可以防止中间人篡改并保证QUIC包体在连接的不同阶段的一致性。那么，防火墙目前能否识别并阻断QUIC类型的流量呢？<br>我们使用QUIC协议访问位于防火墙黑名单中的网站<code>v2ex.com</code>，并抓包分析结果，首先使用传统TCP协议：<br><img src="/post/bypass-gfw-p2/13.png" srcset="/img/loading.gif" lazyload><br>可以看出连接立刻被防火墙阻断，接下来试试QUIC：<br><img src="/post/bypass-gfw-p2/14.png" srcset="/img/loading.gif" lazyload><br>这里Wireshark帮我们解密了<code>Initial Packet</code>，可以看出在包含了黑名单内SNI的情况下，防火墙并没有阻断连接。<br>当然，根据我们上述分析的结果，防火墙是完全有能力识别并阻断QUIC流量的，至于为何没有阻断连接，可能是因为QUIC协议自带加密，同时Client Hello结构与传统TLS的不同，防火墙暂时没有做这方面的适配。<br>也有<a target="_blank" rel="noopener" href="https://gfw.report/publications/usenixsecurity25/en/">研究</a>指出，防火墙其实已经具备了识别并阻断QUIC协议的能力（很遗憾我暂时没有体验到）。但由于对<code>Initial Packet</code>进行解密造成的性能开销，防火墙目前对QUIC流量的处理能力较弱，在1000kpps的混合流量下，80%左右的包都能直接“穿墙而过”，这也算是加密所起到的一个作用吧。<br>最后我们还是得聊聊QUIC的缺点，在境内，基于UDP的协议基本难逃QoS的命运，基于UDP带来的特性看似美好，协议本身却终究难逃高峰时期运营商的限速与阻断。事实上，本文大多写于晚间，在这个时间段，笔者使用家中的宽带始终无法与网站建立QUIC连接，在进行QUIC流量抓包的时候不得不切换到流量上网。</p>
<h1 id="ECH"><a href="#ECH" class="headerlink" title="ECH"></a>ECH</h1><p>前文说到QUIC对Client Hello所在的<code>Initial Packet</code>进行了对称加密，但中间人还是可以根据公开信息解密，那么有没有什么可以彻底加密Client Hello数据的方式呢？这就要提到相关<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/draft-ietf-tls-esni/">RFC标准</a>仍在制定中的ECH（Encrypted Client Hello）了。2018年，Fastly, Cloudflare, Mozilla 等一众研究员和学者提出了<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/draft-ietf-tls-esni/00/">ESNI草案</a>，研究加密Client Hello中SNI扩展的可行性。2020年，协议从ESNI变为ECH，将加密范围从SNI变为整个Client Hello信息，将ALPN和Key Share等能够间接推断出应用层协议的信息也纳入了保护范围。<br>ECH加密Client Hello的方式并非QUIC协议<code>Initial Packet</code>阶段的对称加密，而是与TLS加密类似的非对称加密。如何在TLS握手阶段，服务端密钥还没有发送至客户端的情况下就使用非对称加密呢？解决方案不在TLS协议上，而是<strong>DNS</strong>。<br>DNS并非只能记录域名对应的IP信息，还可以记录许许多多跟域名相关的信息，例如用于将一个域名映射到另一个域名的CNAME记录，用于电子邮件服务器的MX记录等等。而ECH正是利用了其中一种DNS记录类型——SVCB (Service Binding)。<br>SVCB记录原先用于扩展CNAME的功能，除了可以设置映射的域名之外，还可以设置服务所在的端口，ALPN信息等等，举个例子：  </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">svc.example.net.  7200  IN SVCB 3 svc4.example.net. (alpn=&quot;h3,h2&quot; port=&quot;8004&quot; ech=&quot;...&quot; )<br></code></pre></td></tr></table></figure>
<p>SVCB后是记录内容，3代表优先级，<code>svc4.example.net</code>代表可替代的主机端点（<code>TargetName</code>），之后的部分（<code>SvcParams</code>）记录了连接的细节。你可能已经发现了，这里存在一个<code>ech</code>设置项，实际上，这就是解决加密问题的关键：ECH将非对称加密所使用的公钥放在了DNS记录中。<br>事实上，对于HTTPS协议，一般不会直接使用SVCB记录类型记录连接相关的信息，而是使用一种从SVCB记录派生出类的DNS记录类型——HTTPS记录，其结构与SVCB几乎一致，只不过专用于HTTPS协议，以上文提到的被封锁的网站<code>v2ex.com</code>为例，它的HTTPS记录长这样：  </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">v2ex.com.  600  IN  HTTPS  1  .  alpn=&quot;h3,h2&quot;  ipv4hint=172.66.133.207,172.66.137.6  ech=AEX+DQBBrgAgACBFdzOUkqW5BOSqjBlyYnCth1Zys0q2mhTuAgY4m5HzGgAEAAEAAQASY2xvdWRmbGFyZS1lY2guY29tAAA=  ipv6hint=2606:4700:10::ac42:85cf,2606:4700:10::ac42:8906<br></code></pre></td></tr></table></figure>
<p>可以看到，在<code>SvcParams</code>部分记载了ECH所使用的加密公钥，除此之外还有<code>ipv4hint</code>和<code>ipv6hint</code>字段，记载了网站域名对应的IP，这是为了减少DNS查询的次数从而降低延迟。<code>ech</code>是一串使用Base64编码的字符串，试将其解码：  </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">EA Ew3䒥鄤ꌙrbp퇖r㊶ꔮ8둳cloudflare-ech.com<br></code></pre></td></tr></table></figure>
<p>一大串乱码之后是一个域名<code>cloudflare-ech.com</code>，这是客户端所连接的中间服务器的域名，一般是网站的CDN提供商。事实上，ECH将Client Hello分为了外层和内层（<code>Outer ClientHello</code>和<code>Inner ClientHello</code>），客户端在进行HTTPS类型解析后，首先用公钥加密连接至服务端的Client Hello信息，将其放入TLS握手包的<code>encrypted_client_hello</code>扩展中，再将连接至中间服务器的Client Hello信息以明文的形式放在原先的位置。中间服务器收到数据包后，先使用私钥解密<code>encrypted_client_hello</code>扩展中的信息，再根据其中的SNI信息将其转发至对应的后端服务器。这样中间人就只能看见用户连接中间服务器的握手信息，而看不到连接后端服务器的握手信息了。  </p>
<pre><code class=" mermaid">sequenceDiagram
    participant U as 用户 (Client)
    participant M as 中间人 (观察者)
    participant F as 前端服务器 (Gateway/CDN)
    participant B as 后端服务器 (真实网站)

    Note over U,M: DNS下发ECH公钥 (via HTTPS RR / SVCB)

    U-&gt;&gt;F: 发送 Outer ClientHello (包含加密的Inner ClientHello)
    Note right of M: 只能看到Outer ClientHello&lt;br/&gt;及外层SNI (伪装用)
    
    alt 前端服务器支持ECH
        F-&gt;&gt;F: 使用DNS提供的公钥解密Inner ClientHello
        F-&gt;&gt;B: 将解密得到的真实SNI/ALPN等转发给后端服务器
        B--&gt;&gt;F: 返回握手响应 (证书/密钥交换等)
        F--&gt;&gt;U: 返回加密的ServerHello等握手消息
        Note over U,F: 成功建立TLS会话 (真实目标隐藏)
    else 不支持ECH
        F--&gt;&gt;U: 返回ECH失败信号 (ech_required)
        U-&gt;&gt;F: 回退到明文ClientHello
    end
</code></pre>
<p>那么，想要使用上ECH，获取到正确的HTTPS记录就显得尤为重要。如何确保DNS记录不被中间人审查与篡改？这就需要依赖文章前半部分所说的DoT和DoH了。<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="当然，你得使用没有受到污染的 DoH 服务器">[4]</span></a></sup>事实上，虽然ECH相关的草案中没有明确规定，但Google Chrome和Firefox都将使用DoH作为启用ECH的前提条件之一，毕竟根据木桶理论，在使用传统UDP DNS的情况下，隐私方面最短的一块板应该是DNS查询，而非Client Hello中的明文信息。<br><img src="/post/bypass-gfw-p2/17.png" srcset="/img/loading.gif" lazyload alt="在使用UDP协议查询HTTPS类型的记录时，使用境外的DNS会被防火墙识别并直接返回`SERVFAIL`，而境内的DNS服务器似乎根本就不会解析并缓存HTTPS类型的记录"></p>
<p>在使用ECH的情况下，抓包看看访问<code>v2ex.com</code>的结果：<br><img src="/post/bypass-gfw-p2/15.png" srcset="/img/loading.gif" lazyload><br>可以看到在Client Hello阶段，SNI被替换为了中间服务器的地址，同时真正的Client Hello信息加密后放在了<code>encrypted_client_hello</code>扩展中。TLS握手也顺利完成，没有被阻断。  </p>
<p>但是，仍然存在一个小问题：虽然真实的SNI被加密了，但是“存在着被加密的SNI”这件事却是可以被检测到的，毕竟<code>encrypted_client_hello</code>这个扩展就摆在 (Outer) Client Hello 信息中。中间人难道不会通过检测是否存在这个扩展从而阻断所有的ECH流量吗？制定ECH草案的人也想到了这一点，这就是我认为ECH中一个绝妙的设计点：<strong>GREASE</strong>（Generate Random Extensions And Sustain Extensibility）。<br>GREASE并非ECH的首创，其于2016年被提出，并在2020年<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc8701/">标准化</a>，旨在对抗TLS面临的协议僵化 (Protocol Ossification) 问题。具体在RFC的第一节有详细介绍：  </p>
<blockquote>
<p>…TLS follows a model where one side, usually the client, advertises capabilities, and the peer, usually the server, selects them. The responding side must ignore unknown values so that new capabilities may be introduced to the ecosystem while maintaining interoperability.<br>However, bugs may cause an implementation to reject unknown values……when new values are defined, updated peers will discover that the metaphorical joint in the protocol has rusted shut<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里使用了“生锈的关节”这个比喻，这也是为什么这个特性（或者说思想）会被特地命名成 `GREASE`（润滑）">[5]</span></a></sup> and the new values cannot be deployed….<br>To avoid this problem, this document reserves some currently unused values for TLS implementations to advertise at random. Correctly implemented peers will ignore these values and interoperate. Peers that do not tolerate unknown values will fail to interoperate, revealing the mistake before it is widespread.</p>
</blockquote>
<p>GREASE 的目的，就是为了防止中间设备因为协议新特性引入的额外字段而无法正确解析流量，因此采取的一种预防性措施。通过人为增加一些无用的字段，迫使中间设备在解析流量时忽略掉这些字段（而不是抛出错误），从而为协议后续的升级留下空间。<br>回到ECH，GREASE在此处的作用在RFC规范的6.2小节中有说明：  </p>
<blockquote>
<p>The GREASE ECH mechanism allows a connection between and ECH-capable client and a non-ECH server to appear to use ECH, thus reducing the extent to which ECH connections stick out.</p>
</blockquote>
<p>除了上述所说的目的之外，GREASE还可以使ECH数据包和非ECH数据包看起来完全一致，从而对抗审查。具体实现方法就是：对于不支持ECH的网站（例如未在HTTPS记录中配置ECH公钥或是干脆没有HTTPS记录），也在Client Hello数据包内添加<code>encrypted_client_hello</code>扩展，只不过其中的参数都是随机生成的。根据GREASE的相关规范，如果不支持ECH的服务端解析到这个扩展，应该直接将其丢弃，这样就保证了ECH既不会被中间人识别，又不会对旧服务端造成影响。<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="对于 ECH 的 GREASE 在浏览器端实现，支持ECH的浏览器都支持 ECH GREASE">[6]</span></a></sup><br><img src="/post/bypass-gfw-p2/16.png" srcset="/img/loading.gif" lazyload alt="尝试访问不支持ECH的`baidu.com`，同样在Client Hello中看到了`encrypted_client_hello`扩展"></p>
<p>最后还是说说缺点，ECH在可部署性，机密性，抗审查性和前向兼容性方面基本都做到了极致，不过目前支持ECH的网站还是少之又少，目前来看几乎只有使用Cloudflare免费计划的网站支持ECH<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为 Cloudflare 会为免费计划的用户强制启用 ECH，相当于当小白鼠了">[7]</span></a></sup>（当然，是CDN服务器提供的支持），希望在不久的将来ECH能正式标准化，更多网站能支持ECH这项先进的特性。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本期与上期间隔时间较远，主要还是因为笔者对其中的一些概念处于一知半解的状态，集中几天查阅了相关资料才熬出的这篇文章，可以说是很不容易了（<br>但即便如此，文章肯定存在着（可能很多的）错漏，敬请各位海涵，欢迎在评论区与我讨论。<br>虽然标题写的是中篇，但处于一些原因，下篇完成的时间仍是未知数（可能很快，也可能不会有），请各位以不抱期望的心情期待一下（</p>
<h1 id="注释与参考"><a href="#注释与参考" class="headerlink" title="注释与参考"></a>注释与参考</h1><p>本文撰写过程中参考了以下资料：<br><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html">https://www.ruanyifeng.com/blog/2022/08/dns-query.html</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/QUIC">https://en.wikipedia.org/wiki/QUIC</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_protocol_suite">https://en.wikipedia.org/wiki/Internet_protocol_suite</a><br><a target="_blank" rel="noopener" href="https://suntus.github.io/2019/05/09/HKDF%E7%AE%97%E6%B3%95/">https://suntus.github.io/2019/05/09/HKDF%E7%AE%97%E6%B3%95/</a><br><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/encrypted-client-hello/">https://blog.cloudflare.com/encrypted-client-hello/</a><br><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/handshake-encryption-endgame-an-ech-update/">https://blog.cloudflare.com/handshake-encryption-endgame-an-ech-update/</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_DNS_record_types">https://en.wikipedia.org/wiki/List_of_DNS_record_types</a><br><a target="_blank" rel="noopener" href="https://kb.isc.org/docs/svcb-and-https-resource-records-what-are-they">https://kb.isc.org/docs/svcb-and-https-resource-records-what-are-they</a><br>此外还有文章中已经给出的超链接<br>感谢ChatGPT画的mermaid图</p>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>图片来源：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File:HTTP-1.1_vs._HTTP-2_vs._HTTP-3_Protocol_Stack.svg">https://en.wikipedia.org/wiki/File:HTTP-1.1_vs._HTTP-2_vs._HTTP-3_Protocol_Stack.svg</a> , <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><code>DCID</code>即 Destination Connection ID，代表连接对方的ID，初次连接时由客户端随机生成，服务端接收连接后会生成 <code>SCID</code>(Source Connection ID)代表己方发回给客户端，之后的阶段客户端便会使用这个ID作为 <code>DCID</code>，在截图中亦有体现
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>服务端需要生成两组初始密钥，一组用于解密客户端发来的包（<code>client_initial_secret</code>），另一组用于加密发给客户端的 <code>Handshake Packet</code>（<code>server_initial_secret</code>）
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>当然，你得使用没有受到污染的 DoH 服务器
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>这里使用了“生锈的关节”这个比喻，这也是为什么这个特性（或者说思想）会被特地命名成 <code>GREASE</code>（润滑）
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>对于 ECH 的 GREASE 在浏览器端实现，支持ECH的浏览器都支持 ECH GREASE
<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>因为 Cloudflare 会为免费计划的用户强制启用 ECH，相当于当小白鼠了
<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%A0%94%E7%A9%B6%E5%88%86%E4%BA%AB/" class="category-chain-item">研究分享</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/network/" class="print-no-link">#network</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>聊聊那些翻山越岭的神奇操作（中）</div>
      <div>https://blog.kenxu.top/post/bypass-gfw-p2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ken</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/downgrade-bios/" title="记一次降级笔记本BIOS固件的经历">
                        <span class="hidden-mobile">记一次降级笔记本BIOS固件的经历</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://gcore.jsdelivr.net/npm/twikoo@1.6.43/dist/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo.kenxu.top/.netlify/functions/twikoo","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              Fluid.utils.listenDOMLoaded(function() {
                var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
                Fluid.plugins.imageCaption(imgSelector);
                Fluid.plugins.fancyBox(imgSelector);
              });
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Made with ❤️ by Ken | Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
